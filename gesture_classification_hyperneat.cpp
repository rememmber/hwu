//clear && printf '\e[3J' && ghc genotype.c -c && ghc --make -no-hs-main -optc-O -I/usr/local/Cellar/opencv/2.4.10.1/include -L/usr/local/Cellar/opencv/2.4.10.1/lib -lopencv_objdetect -lopencv_core -lopencv_highgui -lopencv_video -lopencv_imgproc -L/usr/lib -lc++ -lc++abi -lm -lc -I/usr/include -lopencv_photo -lopencv_contrib -I/Library/Frameworks/Python.framework/Versions/2.7/include/ -lpython2.7 -L/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/config -I/Applications/ghc-7.10.1.app/Contents/lib/ghc-7.10.1/include stable_version_gesture_recognition.cpp Safe.hs -c && gcc stable_version_gesture_recognition.o genotype.o -o hand -I/usr/local/Cellar/opencv/2.4.10.1/include -L/usr/local/Cellar/opencv/2.4.10.1/lib -lopencv_objdetect -lopencv_core -lopencv_highgui -lopencv_video -lopencv_imgproc -L/usr/lib -lc++ -lc++abi -lm -lc -I/usr/include -lopencv_photo -lopencv_contrib -I/Library/Frameworks/Python.framework/Versions/2.7/include/ -lpython2.7 -L/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/config -I/Applications/ghc-7.10.1.app/Contents/lib/ghc-7.10.1/include

///ghc --make -no-hs-main -optc-O -I/usr/local/Cellar/opencv/2.4.10.1/include -L/usr/local/Cellar/opencv/2.4.10.1/lib -lopencv_objdetect -lopencv_core -lopencv_highgui -lopencv_video -lopencv_imgproc -L/usr/lib -lc++ -lc++abi -lm -lc -I/usr/include -lopencv_photo -lopencv_contrib -I/Library/Frameworks/Python.framework/Versions/2.7/include/ -lpython2.7 -L/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/config -I/Applications/ghc-7.10.1.app/Contents/lib/ghc-7.10.1/include stable_version_gesture_recognition.cpp Safe.hs -c

///ghc genotype.c -c

//ghc -c -O Safe.hs

///gcc stable_version_gesture_recognition.o genotype.o -o hand

//ghc --make -no-hs-main stable_version_gesture_recognition.o genotype.o Safe -o hand -I/usr/local/Cellar/opencv/2.4.10.1/include -L/usr/local/Cellar/opencv/2.4.10.1/lib -lopencv_objdetect -lopencv_core -lopencv_highgui -lopencv_video -lopencv_imgproc -L/usr/lib -lc++ -lc++abi -lm -lc -I/usr/include -lopencv_photo -lopencv_contrib -I/Library/Frameworks/Python.framework/Versions/2.7/include/ -lpython2.7 -L/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/config -I/Applications/ghc-7.10.1.app/Contents/lib/ghc-7.10.1/include

//------

//ghc --make -no-hs-main -optc-O -I/usr/local/Cellar/opencv/2.4.10.1/include -L/usr/local/Cellar/opencv/2.4.10.1/lib -lopencv_objdetect -lopencv_core -lopencv_highgui -lopencv_video -lopencv_imgproc -L/usr/lib -lc++ -lc++abi -lm -lc -I/usr/include -lopencv_photo -lopencv_contrib -I/Library/Frameworks/Python.framework/Versions/2.7/include/ -lpython2.7 -L/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/config -I/Applications/ghc-7.10.1.app/Contents/lib/ghc-7.10.1/include stable_version_gesture_recognition.cpp Safe -c
//ghc --make -no-hs-main stable_version_gesture_recognition.o genotype.o Safe -o hand -I/usr/local/Cellar/opencv/2.4.10.1/include -L/usr/local/Cellar/opencv/2.4.10.1/lib -lopencv_objdetect -lopencv_core -lopencv_highgui -lopencv_video -lopencv_imgproc -L/usr/lib -lc++ -lc++abi -lm -lc -I/usr/include -lopencv_photo -lopencv_contrib -I/Library/Frameworks/Python.framework/Versions/2.7/include/ -lpython2.7 -L/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/config -I/Applications/ghc-7.10.1.app/Contents/lib/ghc-7.10.1/include

//ghc genotype.c -c && ghc -c -O Safe.hs && ghc --make -no-hs-main -optc-O -I/usr/local/Cellar/opencv/2.4.10.1/include -L/usr/local/Cellar/opencv/2.4.10.1/lib -lopencv_objdetect -lopencv_core -lopencv_highgui -lopencv_video -lopencv_imgproc -L/usr/lib -lc++ -lc++abi -lm -lc -I/usr/include -lopencv_photo -lopencv_contrib -I/Library/Frameworks/Python.framework/Versions/2.7/include/ -lpython2.7 -L/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/config -I/Applications/ghc-7.10.1.app/Contents/lib/ghc-7.10.1/include stable_version_gesture_recognition.cpp Safe -c && ghc --make -no-hs-main stable_version_gesture_recognition.o genotype.o Safe -o hand -I/usr/local/Cellar/opencv/2.4.10.1/include -L/usr/local/Cellar/opencv/2.4.10.1/lib -lopencv_objdetect -lopencv_core -lopencv_highgui -lopencv_video -lopencv_imgproc -L/usr/lib -lc++ -lc++abi -lm -lc -I/usr/include -lopencv_photo -lopencv_contrib -I/Library/Frameworks/Python.framework/Versions/2.7/include/ -lpython2.7 -L/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/config -I/Applications/ghc-7.10.1.app/Contents/lib/ghc-7.10.1/include

//ghc genotype.c -c && ghc -c -O Safe.hs && ghc --make -no-hs-main -optc-O -I/usr/local/Cellar/opencv/2.4.10.1/include -L/usr/local/Cellar/opencv/2.4.10.1/lib -lopencv_objdetect -lopencv_core -lopencv_highgui -lopencv_video -lopencv_imgproc -L/usr/lib -lc++ -lc++abi -lm -lc -I/usr/include -lopencv_photo -lopencv_contrib -I/Library/Frameworks/Python.framework/Versions/2.7/include/ -lpython2.7 -L/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/config -I/Applications/ghc-7.10.1.app/Contents/lib/ghc-7.10.1/include stable_version_gesture_recognition.cpp Safe -c && ghc --make -no-hs-main stable_version_gesture_recognition.o genotype.o Safe -o hand -I/usr/local/Cellar/opencv/2.4.10.1/include -L/usr/local/Cellar/opencv/2.4.10.1/lib -lopencv_objdetect -lopencv_core -lopencv_highgui -lopencv_video -lopencv_imgproc -L/usr/lib -lc++ -lc++abi -lm -lc -I/usr/include -lopencv_photo -lopencv_contrib -I/Library/Frameworks/Python.framework/Versions/2.7/include/ -lpython2.7 -L/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/config -I/Applications/ghc-7.10.1.app/Contents/lib/ghc-7.10.1/include -lopencv_flann


#include<opencv2/opencv.hpp>
#include<iostream>
#include<vector>
#include<algorithm>
#include <numeric>
#include <fstream>

#include <HsFFI.h>
#ifdef __GLASGOW_HASKELL__
#include "Safe_stub.h"
extern "C" {
	void __stginit_Safe(void);
}
#endif

extern "C" {
#include "graph.h"
#include "genotype.h"
}

//define NUM_SENSORS 10
//define NUM_hidden 9
//define NUM_CONTEXT 9
//define NUM_WHEELS 2
//define GENOTYPE_SIZE ((NUM_SENSORS + NUM_hidden + NUM_WHEELS) * (NUM_SENSORS + NUM_hidden + NUM_WHEELS))

#define MAX(x, y) (((x) > (y)) ? (x) : (y))
#define MIN(x, y) (((x) < (y)) ? (x) : (y))

// sensor to wheels multiplication matrix
// each each sensor has a weight for each wheel
//double *matrix;
//double temp_array_data[462];
//double node_types[21];
//double temp_matrix[21][21];
//double temp_flat_matrix[441];

//total sensor values during one run
//double sensor_values[NUM_SENSORS];
//double hidden_value[NUM_hidden];
//double hidden_backup[NUM_CONTEXT];
//double wheel_speed[NUM_WHEELS];

// check if a new set of genes was sent by the Supervisor
// in this case start using these new genes immediately

//'sin', 'bound', 'linear', 'gauss', 'sigmoid', 'abs'
double sine(double x){return sin(x);}
double bound(double x){return MAX(-1.0, MIN(x, 1.0));}
double bound_(double x, double l, double r){return MAX(l, MIN(x, r));}
double linear(double x){return x;}
double gauss(double x){return exp((x*x)/2.0)/sqrt(M_PI * 2.0);}
double sigmoid(double x){return 1.0 / (1.0 + exp(-x));}
double abss(double x){return fabs(x);}

// function type
typedef double (*FunctionCallback)(double);
FunctionCallback functions[] = {&sine, &bound, &linear, &gauss, &sigmoid, &abss};

double total_fitness;

#if (defined _WIN32 || defined __WIN64)
    #include <windows.h>
#elif defined __APPLE__    
    #include <spawn.h>
    #include <sys/types.h>
    #include <unistd.h>
#endif


#include <sys/stat.h>

#if (defined _WIN32 || defined __WIN64)
    static char *GENOTYPE_FILE_NAME = "genes"; //"/Users/master/Desktop/test_processes/fifofile";

    static char *GENOTYPE_FITNESS_FILE_NAME = "genes_fitness";

    static char *BEST_GENOTYPE_FILE_NAME = "best_solution"; //"/Users/master/Desktop/test_processes/best_solution";

    static char *PYTHON_PATH = "C:\\Windows\\py.exe "; //used for WIN (for UNIX, path is specified inside the .py file)

    static char *DETECTOR_FILENAME = "detector";

    static char *NN_FILENAME = "classifier\\net";
#elif defined __APPLE__
    static char *GENOTYPE_FILE_NAME = "genes";

    static char *GENOTYPE_FITNESS_FILE_NAME = "genes_fitness";

    static char *BEST_GENOTYPE_FILE_NAME = "best_solution";

    static char *DETECTOR_FILENAME = "detector";

    static char *NN_FILENAME = "classifier/net";
#else
    static char *GENOTYPE_FILE_NAME = "genes";

    static char *GENOTYPE_FITNESS_FILE_NAME = "genes_fitness";

    static char *BEST_GENOTYPE_FILE_NAME = "best_solution";

    static char *DETECTOR_FILENAME = "detector";

    static char *NN_FILENAME = "classifier/net";
#endif

//For peas
extern char **environ;

#if (defined _WIN32 || defined __WIN64)
    const char *python_prog = "peas\\test\\feature_detector"; //"C:\\Users\\ifxboris\\Desktop\\hwu\\peas\\test\\line_following_webots.py"; //"/Users/master/Desktop/peas/peas/peas/test/line_following_webots.py";
#elif defined __APPLE__
    const char *python_prog = "peas/test/feature_detector";
#else
    const char *python_prog = "";
#endif

using namespace std;
using namespace cv;

//create the cascade classifier object used for the face detection
CascadeClassifier face_cascade;
CascadeClassifier upper_body_cascade;
	    //setup image files used in the capture process
	    Mat grayscaleFrame;
	
		typedef struct Limbs
		{
		   cv::Point  start;
		   cv::Point  end;
		   RotatedRect limb_bounding_rectangle;
		   cv::Point break_point;
   		   vector<Point> details;
		} Limb;
		
		typedef struct frame_mapping
		{
			float distance;
			int frameQ;
			int frameP;
		} Frame_Mapping;
		

//This function returns the square of the euclidean distance between 2 points.
double dist(Point x,Point y)
{
	return (x.x-y.x)*(x.x-y.x)+(x.y-y.y)*(x.y-y.y);
}

int lies_on_contour(vector<vector<Point> > contours, Point point)
{
	for(size_t n = 0; n < contours.size(); ++n)
	{
	    auto i = find(contours[n].begin(), contours[n].end(), point);
	    if(contours[n].end() != i)
			return 1;
	}	
	
	return 0;
}

int isEmpty(FILE *file)
{
    long savedOffset = ftell(file);
    fseek(file, 0, SEEK_END);
    
    if (ftell(file) == 0)
    {
        return 1;
    }
    
    fseek(file, savedOffset, SEEK_SET);
    return 0;
}

int file_exist(char *filename)
{
    struct stat   buffer;
    return (stat (filename, &buffer) == 0);
}

//This function returns the radius and the center of the circle given 3 points
//If a circle cannot be formed , it returns a zero radius circle centered at (0,0)
pair<Point,double> circleFromPoints(Point p1, Point p2, Point p3)
{
	double offset = pow(p2.x,2) +pow(p2.y,2);
	double bc =   ( pow(p1.x,2) + pow(p1.y,2) - offset )/2.0;
	double cd =   (offset - pow(p3.x, 2) - pow(p3.y, 2))/2.0;
	double det =  (p1.x - p2.x) * (p2.y - p3.y) - (p2.x - p3.x)* (p1.y - p2.y); 
	double TOL = 0.0000001;
	if (abs(det) < TOL) { /*cout<<"POINTS TOO CLOSE"<<endl;*/ return make_pair(Point(0,0),0); }

	double idet = 1/det;
	double centerx =  (bc * (p2.y - p3.y) - cd * (p1.y - p2.y)) * idet;
	double centery =  (cd * (p1.x - p2.x) - bc * (p2.x - p3.x)) * idet;
	double radius = sqrt( pow(p2.x - centerx,2) + pow(p2.y-centery,2));

	return make_pair(Point(centerx,centery),radius);
}

void initFaces(){
	    //use the haarcascade_frontalface_alt.xml library
	    face_cascade.load("/usr/local/Cellar/opencv/2.4.10.1/share/OpenCV/haarcascades/haarcascade_frontalface_alt.xml");
		upper_body_cascade.load("/usr/local/Cellar/opencv/2.4.10.1/share/OpenCV/haarcascades/haarcascade_mcs_upperbody.xml");
}

vector<Rect> detectFaces(Mat frame){
	        //convert captured image to gray scale and equalize
	        cvtColor(frame, grayscaleFrame, CV_BGR2GRAY);
	        equalizeHist(grayscaleFrame, grayscaleFrame);

	        //create a vector array to store the face found
	        std::vector<Rect> faces;

	        //find faces and store them in the vector array
	        face_cascade.detectMultiScale(grayscaleFrame, faces, 1.05, 3, CV_HAAR_FIND_BIGGEST_OBJECT|CV_HAAR_SCALE_IMAGE, Size(10,10));
	
			return faces;
}

vector<Rect> detectUpperBodies(Mat frame){
	        //convert captured image to gray scale and equalize
	        cvtColor(frame, grayscaleFrame, CV_BGR2GRAY);
	        equalizeHist(grayscaleFrame, grayscaleFrame);

	        //create a vector array to store the face found
	        std::vector<Rect> upperBodies;

	        //find faces and store them in the vector array
	        upper_body_cascade.detectMultiScale(grayscaleFrame, upperBodies, 1.05, 3, CV_HAAR_FIND_BIGGEST_OBJECT|CV_HAAR_SCALE_IMAGE, Size(10,10));
	
			return upperBodies;
}

CvRect rect_intersect(CvRect a, CvRect b) 
{ 
    CvRect r; 
    r.x = (a.x > b.x) ? a.x : b.x;
    r.y = (a.y > b.y) ? a.y : b.y;
    r.width = (a.x + a.width < b.x + b.width) ? 
        a.x + a.width - r.x : b.x + b.width - r.x; 
    r.height = (a.y + a.height < b.y + b.height) ? 
        a.y + a.height - r.y : b.y + b.height - r.y; 
    if(r.width <= 0 || r.height <= 0) 
        r = cvRect(0, 0, 0, 0); 

    return r; 
}

// Adds an edge to an undirected graph
void addEdge(struct Graph* graph, int src, cv::Point src_point, int dest, cv::Point dest_point, float weight)
{
    // Add an edge from src to dest.  A new node is added to the adjacency
    // list of src.  The node is added at the begining
    struct AdjListNode* newNode = newAdjListNode(dest_point, dest, weight);
    newNode->next = graph->array[src].head;
    graph->array[src].head = newNode;
 
    // Since graph is undirected, add an edge from dest to src also
    newNode = newAdjListNode(src_point, src, weight);
    newNode->next = graph->array[dest].head;
    graph->array[dest].head = newNode;

	graph->vertices_added++;
}

int start_capture(int mode, vector<Graph> &string_feature_graph, int limit, float &diagonal_size, int duration, int video_nr){
	
	Mat frame;
	Mat back;
	Mat fore;
	vector<pair<Point,double> > palm_centers;
	
	VideoCapture cap;
	
	std::stringstream ss;
	ss << video_nr;
	
	std::string full_filename;
	string filename = "test_data_";
	full_filename.append(filename);
	full_filename.append(ss.str());
	full_filename.append(".mov");
	
	if(mode == 0){
		cap = VideoCapture(full_filename);
	}
	else if(mode == 1){
		cap = VideoCapture(0);
	}
	// else if(mode == 2){
	// 	cap = VideoCapture(filename2);
	// }
	
	if( !cap.isOpened() )
		return -1;

	BackgroundSubtractorMOG2 bg;
	bg.set("nmixtures",3);
	bg.set("detectShadows",false);


	namedWindow("Frame");
	namedWindow("Background");
	int backgroundFrame=500;
	
	double width = cap.get(CV_CAP_PROP_FRAME_WIDTH);
	double height = cap.get(CV_CAP_PROP_FRAME_HEIGHT);
	diagonal_size = sqrt(width*width + height*height);
	
	int frames=0;
	
		for(int r =0;r<mode==1 ? duration : INFINITY;r++)
		{		
			int hierarchy = 0;

			vector<Limb> potential_limbs;
			vector<vector<Point> > contours;
			//Get the frame
			cap >> frame;
			
			if(frame.empty() || frames==limit)
	            return frames;

			frames++;	
			
			//reduceIllumination(frame);

			vector<Rect> approx_faces = detectFaces(frame);
			vector<Rect> approx_upperBodies = detectUpperBodies(frame);

			//Update the current background model and get the foreground
			if(backgroundFrame>0)
			{bg.operator ()(frame,fore);backgroundFrame--;}
			else
			{bg.operator()(frame,fore,0);}

			//Get background image to display it
			bg.getBackgroundImage(back);


			//Enhance edges in the foreground by applying erosion and dilation
			erode(fore,fore,Mat());
			dilate(fore,fore,Mat());

			//imshow("Frame",fore);

			//Find the contours in the foreground
			findContours(fore,contours,CV_RETR_EXTERNAL,CV_CHAIN_APPROX_TC89_KCOS);
			vector<vector<Point> > newcontours;

				//find biggest face
				cv::Point biggestUpperBodyCenter(-1, -1);
				Rect biggestUpperBody;
				Rect biggestFace;
				cv::Point biggestFaceCenter(-1, -1);
				float biggestFaceArea = 0.0;
				cv::Point possibleElbowStart(-1,-1);
				cv::Point possibleElbowEnd(-1,-1);

				if(approx_faces.size() > 0){
				biggestFace = approx_faces[0];
			    for (int i = 1; i < approx_faces.size(); i++) {
				  if((biggestFace.width * biggestFace.height) < (approx_faces[i].width * approx_faces[i].height))
					biggestFace = approx_faces[i];
			    }

				biggestFaceArea = biggestFace.width * biggestFace.height;
				biggestFaceCenter.x = biggestFace.x + biggestFace.width/2.0;
				biggestFaceCenter.y = biggestFace.y + biggestFace.height/2.0;

				cv::Point pt1(biggestFace.x + biggestFace.width, biggestFace.y + biggestFace.height);
				            cv::Point pt2(biggestFace.x, biggestFace.y);
			//rectangle(frame, pt1, pt2, cvScalar(0, 255, 0, 0), 1, 8, 0);


					//find biggest upper body
					if(approx_upperBodies.size() > 0){
						hierarchy = 1;

					biggestUpperBody = approx_upperBodies[0];
				    for (int i = 1; i < approx_upperBodies.size(); i++) {
					  if((biggestUpperBody.width * biggestUpperBody.height) < (approx_upperBodies[i].width * approx_upperBodies[i].height))
						biggestUpperBody = approx_upperBodies[i];
				    }	

				    biggestUpperBodyCenter.x = biggestUpperBody.x + biggestUpperBody.width/2.0;
				    biggestUpperBodyCenter.y = biggestFace.y+biggestFace.height;
				//intersection between face and upper body
				//Rect head_upper_body_intersection = rect_intersect(biggestUpperBody, biggestFace);
					cv::Point pt3(biggestUpperBody.x + biggestUpperBody.width, biggestUpperBody.y + biggestUpperBody.height);
					            cv::Point pt4(biggestUpperBody.x, biggestFace.y+biggestFace.height);
				//rectangle(frame, pt3, pt4, cvScalar(0, 255, 0, 0), 1, 8, 0);
			}

			for(int i=0;i<contours.size();i++){
				RotatedRect rect_test=minAreaRect(Mat(contours[i]));
					Rect intersectionRectangle = rect_intersect(biggestFace, rect_test.boundingRect());
					if((intersectionRectangle.width * intersectionRectangle.height) > biggestFaceArea * 0.5){
						//contours.erase(contours.begin()+i);
						//printf("fingers on the face\n");
					}else{
						newcontours.push_back(contours[i]);
					}
			}
		}else{
			newcontours = contours;
		}

			for(int i=0;i<newcontours.size();i++)
				//Ignore all small insignificant areas
				if(contourArea(newcontours[i])>=(biggestFaceArea * 0.3) && (biggestFaceArea > 0.0))		    
				{
					possibleElbowStart.x = -1;
					possibleElbowStart.y = -1;
					possibleElbowEnd.x = -1;
					possibleElbowEnd.y = -1;

					vector<Point2f> limb_details_temp;

					Limb limb;
	      			//default
	      			limb.start.x = -1;
	      			limb.start.y = -1;
	      			limb.end.x = -1;
	      			limb.end.y = -1;
	      			limb.break_point.x = -1;
	      			limb.break_point.y = -1;
					//Draw contour
					vector<vector<Point> > tcontours;
					tcontours.push_back(newcontours[i]);
					//drawContours(frame,tcontours,-1,cv::Scalar(0,0,255),2);

					//Detect Hull in current contour
					vector<vector<Point> > hulls(1);
					vector<vector<int> > hullsI(1);
					convexHull(Mat(tcontours[0]),hulls[0],false);
					convexHull(Mat(tcontours[0]),hullsI[0],false);
					//drawContours(frame,hulls,-1,cv::Scalar(0,255,0),2);

					//Find minimum area rectangle to enclose hand
					RotatedRect rect=minAreaRect(Mat(tcontours[0]));
					Point2f vertices[4];
					rect.points(vertices);

					//is a limb?
	          			//RotatedRect potential_limb_contour = minAreaRect(Mat(newcontours[i]));  					
	          			biggestUpperBody.y = biggestFace.y+biggestFace.height;
	          			biggestUpperBody.height = biggestUpperBody.height-biggestFace.height;

						Rect biggestUpperBodyTemp(biggestUpperBody.tl(), biggestUpperBody.size());  //use copy for expansion

						//extends biggest upper body in width
						cv::Size deltaSize( biggestUpperBodyTemp.width *.5, biggestUpperBodyTemp.height);
						cv::Point offset( deltaSize.width/2, deltaSize.height/2);
						biggestUpperBodyTemp += deltaSize;
						biggestUpperBodyTemp -= offset;

	          			Rect potential_limb_intersections = rect_intersect(rect.boundingRect(), biggestUpperBodyTemp);

						//extend intersection rectangle
						cv::Size deltaSize2( potential_limb_intersections.width * .1, potential_limb_intersections.height * .1 );
						cv::Point offset2( deltaSize2.width/2, deltaSize2.height/2);
						potential_limb_intersections += deltaSize2;
						potential_limb_intersections -= offset2;

	          			if(potential_limb_intersections.width * potential_limb_intersections.height > rect.boundingRect().width * rect.boundingRect().height * 0.1){
							hierarchy = 2;
	                    			for(int m=0;m<4;m++)
	                              		  if(dist(limb.start, limb.end) < dist((vertices[m] + vertices[(m+1)%4])*.5, (vertices[(m+2)%4] + vertices[(m+3)%4])*.5) && potential_limb_intersections.contains((vertices[m] + vertices[(m+1)%4])*.5) /* && potential_limb_intersections.contains(vertices[(m+1)%4])*/)
	                              		  {
	                              		    //Limb limb;
	                              		    limb.start = (vertices[m] + vertices[(m+1)%4])*.5;
	                              		    limb.end = (vertices[(m+2)%4] + vertices[(m+3)%4])*.5;
	                              		    limb.limb_bounding_rectangle = rect;
	                              		    //potential_limbs.push_back(limb);
	                              		  }
	          			}

					//Find Convex Defects
					vector<Vec4i> defects;
					if(hullsI[0].size()>0)
					{
						Point2f rect_points[4]; rect.points( rect_points );
						//for( int j = 0; j < 4; j++ )
						//	line( frame, rect_points[j], rect_points[(j+1)%4], Scalar(255,0,0), 1, 8 );
						Point rough_palm_center;
						convexityDefects(tcontours[0], hullsI[0], defects);
						if(defects.size()>=3)
						{
							vector<Point> palm_points;
							for(int j=0;j<defects.size();j++)
							{
								int startidx=defects[j][0]; Point ptStart( tcontours[0][startidx] );
								int endidx=defects[j][1]; Point ptEnd( tcontours[0][endidx] );
								int faridx=defects[j][2]; Point ptFar( tcontours[0][faridx] );

								//Sum up all the hull and defect points to compute average
								rough_palm_center+=ptFar+ptStart+ptEnd;
								palm_points.push_back(ptFar);
								palm_points.push_back(ptStart);
								palm_points.push_back(ptEnd);
							}

							//Get palm center by 1st getting the average of all defect points, this is the rough palm center,
							//Then U chose the closest 3 points ang get the circle radius and center formed from them which is the palm center.
							rough_palm_center.x/=defects.size()*3;
							rough_palm_center.y/=defects.size()*3;
							Point closest_pt=palm_points[0];
							vector<pair<double,int> > distvec;
							for(int i=0;i<palm_points.size();i++)
								distvec.push_back(make_pair(dist(rough_palm_center,palm_points[i]),i));
							sort(distvec.begin(),distvec.end());

							//Keep choosing 3 points till you find a circle with a valid radius
							//As there is a high chance that the closes points might be in a linear line or too close that it forms a very large circle
							pair<Point,double> soln_circle;
							for(int i=0;i+2<distvec.size();i++)
							{
								Point p1=palm_points[distvec[i+0].second];
								Point p2=palm_points[distvec[i+1].second];
								Point p3=palm_points[distvec[i+2].second];
								soln_circle=circleFromPoints(p1,p2,p3);//Final palm center,radius
								if(soln_circle.second!=0)
									break;
							}

							//Find avg palm centers for the last few frames to stabilize its centers, also find the avg radius
							palm_centers.push_back(soln_circle);
							if(palm_centers.size()>10)
								palm_centers.erase(palm_centers.begin());

							Point palm_center;
							double radius=0;
							for(int i=0;i<palm_centers.size();i++)
							{
								palm_center+=palm_centers[i].first;
								radius+=palm_centers[i].second;
							}
							palm_center.x/=palm_centers.size();
							palm_center.y/=palm_centers.size();
							radius/=palm_centers.size();

							//Draw the palm center and the palm circle
							//The size of the palm gives the depth of the hand
							//circle(frame,palm_center,5,Scalar(144,144,255),3);
							//circle(frame,palm_center,radius,Scalar(144,144,255),2);

							//Detect fingers by finding points that form an almost isosceles triangle with certain thesholds
							int no_of_fingers=0;
							for(int j=0;j<defects.size();j++)
							{
								int startidx=defects[j][0]; Point ptStart( tcontours[0][startidx] );
								int endidx=defects[j][1]; Point ptEnd( tcontours[0][endidx] );
								int faridx=defects[j][2]; Point ptFar( tcontours[0][faridx] );
								//X o--------------------------o Y
								double Xdist=sqrt(dist(palm_center,ptFar));
								double Ydist=sqrt(dist(palm_center,ptStart));
								double length=sqrt(dist(ptFar,ptStart));

	//circle(frame,ptStart,5,Scalar(0,0,255),3);

								double retLength=sqrt(dist(ptEnd,ptFar));
								//Play with these thresholds to improve performance
								if(length<=3*radius&&Ydist>=0.4*radius&&length>=10&&retLength>=10&&max(length,retLength)/min(length,retLength)>=0.8)
									if(min(Xdist,Ydist)/max(Xdist,Ydist)<=0.8)
									{
										if((Xdist>=0.1*radius&&Xdist<=1.3*radius&&Xdist<Ydist)||(Ydist>=0.1*radius&&Ydist<=1.3*radius&&Xdist>Ydist)){
											if(dist(ptEnd, limb.end) <= dist(limb.start, limb.end) * .1){
												hierarchy = 3;
											  limb_details_temp.push_back(Point2f(ptEnd.x, ptEnd.y));
											}

											//line( frame, ptEnd, ptFar, Scalar(0,255,0), 1 );
											no_of_fingers++;


											if(dist(ptStart, limb.start) >= std::min(rect.boundingRect().width, rect.boundingRect().height)*.2 && dist(ptStart, limb.end) >= std::min(rect.boundingRect().width, rect.boundingRect().height)*.2 && lies_on_contour(newcontours, ptStart) && dist(ptStart, ptEnd) > dist(possibleElbowStart, possibleElbowEnd)){
												possibleElbowStart = ptStart;
												possibleElbowEnd = ptEnd;
											}
										}

									}


							}


							//circle(frame,possibleElbowStart,5,Scalar(0,255,0),3);
							//circle(frame,possibleElbowEnd,5,Scalar(255,0,0),3);

							no_of_fingers=min(5,no_of_fingers);
							//cout<<"NO OF FINGERS: "<<no_of_fingers<<endl;


						}

					}

					if(limb_details_temp.size() > 0){
						//std::cout << "data:" << limb_details_temp << std::endl;
						Mat labels;
						int cluster_number = std::min(5, (int)limb_details_temp.size());
						TermCriteria criteria = TermCriteria( CV_TERMCRIT_EPS + CV_TERMCRIT_ITER, 10, 1.0 );
						Mat centers;
						kmeans(limb_details_temp, cluster_number, labels, criteria, 1, KMEANS_PP_CENTERS, centers);
						//std::cout << "centers:" << centers << std::endl;
						//std::cout << "labels:" << labels << std::endl;

						for(int h=0;h<centers.rows;h++)
							limb.details.push_back(Point(centers.at<float>(h,0), centers.at<float>(h,1)));

				    }

					limb.break_point = possibleElbowStart;
					potential_limbs.push_back(limb);

				}


				Mat skeletonFrame = Mat(frame.rows*.5,frame.cols*.5, CV_8UC3, cv::Scalar(255,255,255));
				double rad = 5;
				double scale_factor = .5;
		        //face
		        //scene->addEllipse( initialPoint.x+biggestFaceCenter.x-rad, initialPoint.y+biggestFaceCenter.y-rad, rad*2.0, rad*2.0, QPen(), QBrush(Qt::SolidPattern) );
				Point faceCenter(biggestFaceCenter.x*scale_factor, biggestFaceCenter.y*scale_factor);
				circle(skeletonFrame,faceCenter,rad,Scalar(0,0,0),2);

		        if((biggestUpperBodyCenter.x != -1) || (biggestUpperBodyCenter.y != -1)){                     
		          //neck
		          //scene->addEllipse( initialPoint.x+biggestUpperBodyCenter.x-rad, initialPoint.y+biggestUpperBodyCenter.y-rad, rad*2.0, rad*2.0, QPen(), QBrush(Qt::SolidPattern) );
		          //scene->addLine(initialPoint.x+biggestFaceCenter.x, initialPoint.y+biggestFaceCenter.y,  initialPoint.x+biggestUpperBodyCenter.x, initialPoint.y+biggestUpperBodyCenter.y, QPen());                   
				  Point neckCenter(biggestUpperBodyCenter.x*scale_factor, biggestUpperBodyCenter.y*scale_factor);
				  circle(skeletonFrame,neckCenter,rad,Scalar(0,0,0),2);
				  line( skeletonFrame, faceCenter, neckCenter, Scalar(0,0,0), 1, 8 );

		          //shoulders
		          //scene->addEllipse( initialPoint.x+biggestUpperBodyCenter.x-biggestUpperBody.width/2.0-rad, initialPoint.y+biggestUpperBodyCenter.y-rad, rad*2.0, rad*2.0, QPen(), QBrush(Qt::SolidPattern) );
		          //scene->addLine(initialPoint.x+biggestUpperBodyCenter.x, initialPoint.y+biggestUpperBodyCenter.y, initialPoint.x+biggestUpperBodyCenter.x-biggestUpperBody.width/2.0, initialPoint.y+biggestUpperBodyCenter.y, QPen());
		          //scene->addEllipse( initialPoint.x+biggestUpperBodyCenter.x+biggestUpperBody.width/2.0-rad, initialPoint.y+biggestUpperBodyCenter.y-rad, rad*2.0, rad*2.0, QPen(), QBrush(Qt::SolidPattern)  );
		          //scene->addLine(initialPoint.x+biggestUpperBodyCenter.x, initialPoint.y+biggestUpperBodyCenter.y, initialPoint.x+biggestUpperBodyCenter.x+biggestUpperBody.width/2.0, initialPoint.y+biggestUpperBodyCenter.y, QPen());

				  Point shoulder1Center((biggestUpperBodyCenter.x-biggestUpperBody.width/2.0)*scale_factor, biggestUpperBodyCenter.y*scale_factor);
				  circle(skeletonFrame,shoulder1Center,rad,Scalar(0,0,0),2);
				  Point shoulder2Center((biggestUpperBodyCenter.x+biggestUpperBody.width/2.0)*scale_factor, biggestUpperBodyCenter.y*scale_factor);
				  circle(skeletonFrame,shoulder2Center,rad,Scalar(0,0,0),2);

				  //waist
				  Point waistCenter((biggestUpperBody.tl().x + biggestUpperBody.width/2.0)*scale_factor, (biggestUpperBody.tl().y+biggestUpperBody.height)*scale_factor);
				  circle(skeletonFrame,waistCenter,rad,Scalar(0,0,0),2);
		        }

		        for(int p=0; p<potential_limbs.size(); p++){
		          //scene->addEllipse( initialPoint.x+potential_limbs[p].end.x-rad, initialPoint.y+potential_limbs[p].end.y-rad, rad*2.0, rad*2.0, QPen(), QBrush(Qt::SolidPattern) );
		          //scene->addLine(initialPoint.x+initialPoint.x+potential_limbs[p].start.x, initialPoint.y+initialPoint.x+potential_limbs[p].start.y, initialPoint.x+initialPoint.x+potential_limbs[p].end.x, initialPoint.y+initialPoint.x+potential_limbs[p].end.y, QPen());

				  if(potential_limbs[p].break_point.x != -1 && potential_limbs[p].break_point.y != -1 && potential_limbs[p].start.x != -1 && potential_limbs[p].start.y != -1 && potential_limbs[p].end.x != -1 && potential_limbs[p].end.y != -1){
					Point limbEnd(potential_limbs[p].end.x*scale_factor, potential_limbs[p].end.y*scale_factor);
				  	circle(skeletonFrame,limbEnd,rad,Scalar(0,0,255),2);
					Point limbMiddle(potential_limbs[p].break_point.x*scale_factor, potential_limbs[p].break_point.y*scale_factor);
				  	circle(skeletonFrame,limbMiddle,rad,Scalar(0,0,0),2);
				  	Point limbStart(potential_limbs[p].start.x*scale_factor, potential_limbs[p].start.y*scale_factor);
				  	line( skeletonFrame, limbStart, limbMiddle, Scalar(0,0,255), 1, 8 );
					line( skeletonFrame, limbMiddle, limbEnd, Scalar(0,0,0), 1, 8 );
				  }else{
					  if(potential_limbs[p].start.x != -1 && potential_limbs[p].start.y != -1 && potential_limbs[p].end.x != -1 && potential_limbs[p].end.y != -1){
				  		Point limbEnd(potential_limbs[p].end.x*scale_factor, potential_limbs[p].end.y*scale_factor);
				  		circle(skeletonFrame,limbEnd,rad,Scalar(0,0,0),2);
				  		Point limbStart(potential_limbs[p].start.x*scale_factor, potential_limbs[p].start.y*scale_factor);
				  		line( skeletonFrame, limbStart, limbEnd, Scalar(0,0,0), 1, 8 );
				      }
			  	  }

				  //details
				  for(int l=0; l<potential_limbs[p].details.size(); l++){
					if(dist(potential_limbs[p].details[l], potential_limbs[p].break_point) != 0.0){
						Point limb_detal(potential_limbs[p].details[l].x*scale_factor, potential_limbs[p].details[l].y*scale_factor);
						circle(skeletonFrame,limb_detal,rad,Scalar(0,0,0),2);
					}
				  }
		        }

					//0-face
					//1-hand1
					//2-hand2
					//3-shoulder1
					//4-shoulder2
					//5-elbow1
					//6-elbow2
		    		// create the graph given in above fugure
	        		int V = 7;
	        		struct Graph* graph = createGraph(V);

					//features
					int item = 1;

					//hierarchy
					std::stringstream s00;
					s00 << "hierarchy: " << hierarchy;
					putText(skeletonFrame, s00.str(), cvPoint(30,15*(item++)), FONT_HERSHEY_COMPLEX_SMALL, 0.8, cvScalar(200,200,250), 1, CV_AA);

					//face-hand
					std::stringstream s0;
					s0 << "face-hand-1: ";
					if(potential_limbs.size() > 0){
						s0 << (int)round(sqrt(dist(faceCenter, potential_limbs[0].end)));
						addEdge(graph, 0, faceCenter, 1, potential_limbs[0].end, sqrt(dist(faceCenter, potential_limbs[0].end))); //face-hand1
					}
					else{
						s0 << "-";
						//addEdge(graph, 0, Point(0,0), 1, Point(0,0), 0); //face-hand1
					}
					putText(skeletonFrame, s0.str(), cvPoint(30,15*(item++)), FONT_HERSHEY_COMPLEX_SMALL, 0.8, cvScalar(200,200,250), 1, CV_AA);
					std::stringstream s;
					s << "face-hand-2: ";
					if(potential_limbs.size() > 1){
						s << (int)round(sqrt(dist(faceCenter, potential_limbs[1].end)));
						addEdge(graph, 0, faceCenter, 2, potential_limbs[1].end, sqrt(dist(faceCenter, potential_limbs[1].end))); //face-hand2
					}else{
						s << "-";
						//addEdge(graph, 0, Point(0,0), 2, Point(0,0), 0); //face-hand2
					}
					putText(skeletonFrame, s.str(), cvPoint(30,15*(item++)), FONT_HERSHEY_COMPLEX_SMALL, 0.8, cvScalar(200,200,250), 1, CV_AA);


					//hand-hand
					std::stringstream s1;
					s1 << "hand-hand: ";
					if(potential_limbs.size() == 2){
						s1 << (int)round(sqrt(dist(potential_limbs[1].end, potential_limbs[0].end)));
						addEdge(graph, 1, potential_limbs[1].end, 2, potential_limbs[0].end, sqrt(dist(potential_limbs[1].end, potential_limbs[0].end))); //hand1-hand2 (same as hand2-hand1)
					}else{
						s1 << "-";
						//addEdge(graph, 1, Point(0,0), 2, Point(0,0), 0); //hand1-hand2 (same as hand2-hand1)
					}
					putText(skeletonFrame, s1.str(), cvPoint(30,15*(item++)), FONT_HERSHEY_COMPLEX_SMALL, 0.8, cvScalar(200,200,250), 1, CV_AA);

					//shoulder-shoulder
					Point shoulder1((biggestUpperBody.x + biggestUpperBody.width/2.0-biggestUpperBody.width/2.0)*scale_factor, (biggestFace.y+biggestFace.height)*scale_factor);
					Point shoulder2((biggestUpperBody.x + biggestUpperBody.width/2.0+biggestUpperBody.width/2.0)*scale_factor, (biggestFace.y+biggestFace.height)*scale_factor);
					std::stringstream s2;
					s2 << "shoulder-shoulder: " << (int)round(sqrt(dist(shoulder1, shoulder2)));
					putText(skeletonFrame, s2.str(), cvPoint(30,15*(item++)), FONT_HERSHEY_COMPLEX_SMALL, 0.8, cvScalar(200,200,250), 1, CV_AA);
					addEdge(graph, 3, shoulder1, 4, shoulder2, sqrt(dist(shoulder1, shoulder2))); //shoulder1-shoulder2 (same as shoulder2-shoudler1)

					//elbow-elbow
					std::stringstream s3;
					s3 << "elbow-elbow: ";
					if(potential_limbs.size() == 2){
						s3 << (int)round(sqrt(dist(potential_limbs[0].break_point, potential_limbs[1].break_point)));
						addEdge(graph, 5, potential_limbs[0].break_point, 6, potential_limbs[1].break_point, sqrt(dist(potential_limbs[0].break_point, potential_limbs[1].break_point))); //elbow1-elbow2 (same as elbow2-elbow1)
					}else{
						s3 << "-";
						//addEdge(graph, 5, Point(0,0), 6, Point(0,0), 0); //elbow1-elbow2 (same as elbow2-elbow1)
					}
					putText(skeletonFrame, s3.str(), cvPoint(30,15*(item++)), FONT_HERSHEY_COMPLEX_SMALL, 0.8, cvScalar(200,200,250), 1, CV_AA);


					imshow("Frame2",skeletonFrame);



	        		// print the adjacency list representation of the above graph
	        		//printGraph(graph);
					string_feature_graph.push_back(*graph);

					//if(backgroundFrame>0)
					//	putText(frame, "Recording Background", cvPoint(30,30), FONT_HERSHEY_COMPLEX_SMALL, 0.8, cvScalar(200,200,250), 1, CV_AA);
					putText(frame, "Preview", cvPoint(30,30), FONT_HERSHEY_COMPLEX_SMALL, 0.8, cvScalar(200,200,250), 1, CV_AA);
					imshow("Frame",frame);
					//imshow("Background",back);
					if(waitKey(10) >= 0) break;


		}
		
		return -1;
}

/** * Determines the angle of a straight line drawn between point one and two.
 The number returned, which is a float in degrees, 
 tells us how much we have to rotate a horizontal line clockwise for it to match the line between the two points. * 
 If you prefer to deal with angles using radians instead of degrees, 
 just change the last line to: "return atan2(yDiff, xDiff);" */ 
float GetAngleOfLineBetweenTwoPoints(cv::Point p1, cv::Point p2) 
{ 
	float xDiff = p2.x - p1.x;
	float yDiff = p2.y - p1.y; 
	
	return atan2(yDiff, xDiff) * (180 / M_PI); 
}

Mat match_strings(vector<Graph> test, vector<Graph> query, float max_length){
	//printf("sizes: %d and %d\n", (int)test.size(), (int)query.size());
	Mat M = Mat(test.size()*7,test.size()*7, CV_32F, cvScalar(0.));
	//46
	
	for(std::vector<Graph>::iterator test_it = test.begin(); test_it != test.end(); ++test_it) {
		for(std::vector<Graph>::iterator query_it = query.begin(); query_it != query.end(); ++query_it) {
			if((&(*test_it))->vertices_added == (&(*query_it))->vertices_added){
		    	int v;
		    	for (v = 0; v < (&(*test_it))->V; ++v)
		    	{
					int v2;
				    for (v2 = 0; v2 < (&(*query_it))->V; ++v2)
				    {
						//if((&(*test_it))->array[v].head == NULL) continue;
		    	    	struct AdjListNode* pCrawl = (&(*test_it))->array[v].head;
		    	    	while (pCrawl)
		    	    	{
							//if((&(*query_it))->array[v2].head == NULL) continue;
					        struct AdjListNode* pCrawl2 = (&(*query_it))->array[v2].head;
					        while (pCrawl2)
					        {
								//printf("-> %d (%f) (@ %d, %d) ", pCrawl->dest, pCrawl->weight, pCrawl->position.x, pCrawl->position.y);
					            //printf("-> %d (%f) (@ %d, %d) ", pCrawl2->dest, pCrawl2->weight, pCrawl2->position.x, pCrawl2->position.y);
								if((pCrawl->dest) == (pCrawl2->dest)){
									float dn = sqrt(dist(pCrawl->position, pCrawl2->position))/max_length;
									
									if(dn <= max_length*0.01/max_length){
										if(max_length > 0.0)
											M.at<float>(std::distance(test.begin(), test_it)*7+pCrawl->dest, std::distance(query.begin(), query_it)*7+pCrawl2->dest) = max_length*0.01/max_length - dn;
										else
											M.at<float>(std::distance(test.begin(), test_it)*7+pCrawl->dest, std::distance(query.begin(), query_it)*7+pCrawl2->dest) = 0.0;
									}else{
										M.at<float>(std::distance(test.begin(), test_it)*7+pCrawl->dest, std::distance(query.begin(), query_it)*7+pCrawl2->dest) = 0.0;
									}
								}else{
									//M[test_it - test.begin()][query_it - query.begin()] = 0.0;
									float de1 = 0.0;
									float de2 = 0.0;
									
									for(std::vector<Graph>::iterator test_it_dest = test.begin(); test_it_dest != test.end(); ++test_it_dest) {
										int v_dest;
									    for (v_dest = 0; v_dest < (&(*test_it_dest))->V; ++v_dest)
									    {
									        struct AdjListNode* pCrawl_test_dest = (&(*test_it_dest))->array[v_dest].head;
									        while (pCrawl_test_dest)
									        {
												if(pCrawl_test_dest->dest == pCrawl->dest)
													de1 = GetAngleOfLineBetweenTwoPoints(pCrawl->position, pCrawl_test_dest->position) / 360.0;
												pCrawl_test_dest = pCrawl_test_dest->next;
											}
										}
									}
									
									for(std::vector<Graph>::iterator query_it_dest = query.begin(); query_it_dest != query.end(); ++query_it_dest) {
										int v2_dest;
									    for (v2_dest = 0; v2_dest < (&(*query_it_dest))->V; ++v2_dest)
									    {
									        struct AdjListNode* pCrawl_query_dest = (&(*query_it_dest))->array[v2_dest].head;
									        while (pCrawl_query_dest)
									        {
												if(pCrawl_query_dest->dest == pCrawl2->dest)
													de2 = GetAngleOfLineBetweenTwoPoints(pCrawl2->position, pCrawl_query_dest->position) / 360.0;
												pCrawl_query_dest = pCrawl_query_dest->next; 
											}
										}
									}
									
									
									float de_diff = abs(de1-de2);
									
									if(de_diff/360.0 <= 360.0*0.01/360.0){
										M.at<float>(std::distance(test.begin(), test_it)*7+pCrawl->dest, std::distance(query.begin(), query_it)*7+pCrawl2->dest) = 360.0*0.01/360.0 - de_diff/360.0;
										M.at<float>(std::distance(query.begin(), query_it)*7+pCrawl2->dest, std::distance(test.begin(), test_it)*7+pCrawl->dest) = 360.0*0.01/360.0 - de_diff/360.0; //symmetry
									}else{
										M.at<float>(std::distance(test.begin(), test_it)*7+pCrawl->dest, std::distance(query.begin(),query_it)*7+pCrawl2->dest) = 0.0;
										M.at<float>(std::distance(query.begin(),query_it)*7+pCrawl2->dest, std::distance(test.begin(),test_it)*7+pCrawl->dest) = 0.0;
									}
								}
					
					            pCrawl2 = pCrawl2->next;
					        }
							pCrawl = pCrawl->next;
					    }
		    	    }
		    	}
			}
		}
	}
	
	return M;
}

void read_ann(Genotype genotype, char *NEW_GENOTYPE_FILE_NAME, char *NEW_GENOTYPE_FITNESS_FILE_NAME, int with_removal, int node_types_specified) {	
    int times = 0;
    int redo = 1;
    while(redo){
        FILE *fp = fopen(NEW_GENOTYPE_FILE_NAME, "rb");
        if ( fp == NULL ){
            fclose(fp);
            sleep(1);
            continue;
            read_ann(genotype, NEW_GENOTYPE_FILE_NAME, NEW_GENOTYPE_FITNESS_FILE_NAME, with_removal, node_types_specified);
        }
        
        while ( !feof (fp) )
        {
            redo = 0;
            if(isEmpty(fp)){
            fclose(fp);
                continue;
            }else{
                times++;
                
                if(times <= 1){
                    int result = genotype_fread(genotype, fp, node_types_specified);
                    fclose(fp);
                    //removing file instead
					if(with_removal)
                    	remove(NEW_GENOTYPE_FILE_NAME);
                    
                    total_fitness = 0.0;
                    //evaluate_genotype(genotype);
                    break;
                }else{
                    break;
                }
            }
            
        }
    }
    
    if((with_removal && file_exist(NEW_GENOTYPE_FILE_NAME)) || (with_removal && file_exist(NEW_GENOTYPE_FITNESS_FILE_NAME))){
        read_ann(genotype, NEW_GENOTYPE_FILE_NAME, NEW_GENOTYPE_FITNESS_FILE_NAME, with_removal, node_types_specified);
    }
}

double round_to_decimal(float f) {
    char buf[42];
    sprintf(buf, "%.7g", f); // round to 7 decimal digits
    return atof(buf);
}

double feed(Genotype genotype, Mat matrix, int type) {
    //steps = 0; //reset steps for the next evaluation
    
    // double data_values[genotype_get_size()+(int)sqrt(genotype_get_size())]; //set data size for array to receive data from controller
    // int i;
    // for (i=0; i<(int)sqrt(genotype_get_size()); i++){
    //     data_values[i] = genotype_get_node_types(genotype)[i];
    // }
    // for (i=(int)sqrt(genotype_get_size()); i<genotype_get_size()+(int)sqrt(genotype_get_size()); i++){
    //     data_values[i] = genotype_get_genes(genotype)[i-(int)sqrt(genotype_get_size())];
    // }
    
    //wb_emitter_send(emitter, data_values, (genotype_get_size()+(int)sqrt(genotype_get_size()))*sizeof(double));
    
    //free(genotype);
    
    // reset robot and load position
    //wb_supervisor_field_set_sf_vec3f(robot_translation, robot_trans0);
    //wb_supervisor_field_set_sf_rotation(robot_rotation, robot_rot0);
    
    // evaluation genotype during one minute
    //run_seconds(240.0);
    
    // measure fitness
    //double fitness = measure_fitness();

    //char output[50];
    //snprintf(output,50,"%f",fitness);
    
    //FILE *file;
    //file = fopen(GENOTYPE_FITNESS_FILE_NAME,"w"); //fopen("/Users/master/Desktop/test_processes/fifofile_fitness","w");
    //fprintf(file, output);
    //fclose(file);



	double* matrixzvector = (double *)malloc(sizeof(double)*(matrix.rows * matrix.cols));
	int mm=0;
	for (int nr=0; nr<matrix.rows; nr++){ 
	    for (int nc=0; nc<matrix.cols; nc++){ 
	        matrixzvector[mm]=round_to_decimal(matrix.at<float>(nr,nc));
	        mm=mm+1;
	    }
	}
	
	double* node_types = (double *)malloc(sizeof(double)*(int)sqrt(genotype_get_size()));
	double* flat_matrix = (double *)malloc(sizeof(double)*(genotype_get_size()));

    for (int i=0; i<(int)sqrt(genotype_get_size()); i++){
        node_types[i] = 0;//genotype_get_node_types(genotype)[i];
    }

    for (int i=0; i<genotype_get_size(); i++){
		//cout << genotype_get_genes(genotype)[i];
        flat_matrix[i] = genotype_get_genes(genotype)[i];
    }
	//cout << endl;

	//count cells eligible
	//int n=0;
	// cv::Mat refactred_weight_matrix_mat = cv::Mat((int)sqrt(genotype_get_size()), (int)sqrt(genotype_get_size()), CV_64F, flat_matrix);
	// 	
	// 	Mat level_1 = refactred_weight_matrix_mat(cv::Rect(0,441,441,16));
	// 	Mat level_2 = refactred_weight_matrix_mat(cv::Rect(441,441+16,16,1));
	
	//cout << "level1 " << level_1 << endl;
	//cout << "level2 " << level_2 << endl;
	
	// double* flat_matrix2 = (double *)malloc(sizeof(double)*((level_1.cols*level_1.rows)+(level_2.cols*level_2.rows)));
	// 
	// int p=-1;
	// for(int i=0;i<level_1.rows;i++)
	// 	for(int j=0;j<level_1.cols;j++)
	// 		flat_matrix2[++p] = level_1.at<double>(i,j);
	//     
	// for(int i=0;i<level_2.rows;i++)
	// 	for(int j=0;j<level_2.cols;j++)
	// 		flat_matrix2[++p] = level_2.at<double>(i,j);
			
	//cout << "p: " << p << " and size: " << (level_1.cols*level_1.rows)+(level_2.cols*level_2.rows) << endl;
	
	// int level=0;
	// for(int i=441; i<refactred_weight_matrix_mat.rows; i++){
	// 	if(i<(441+16)) level=1; else level=2;
	// 	for(int j=(level==1)?0:(441+16); j<refactred_weight_matrix_mat.cols-(level==1)?16:0; j++){
	// 		n++;
	// 	}
	// }
	// 
	// //refactored weight matrix
	// mm=-1;
	// double* refactred_weight_matrix = (double *)malloc(sizeof(double)*(n));
	// level=0;
	// for(int i=441; i<refactred_weight_matrix_mat.rows; i++){
	// 	if(i<(441+16)) level=1; else level=2;
	// 	for(int j=(level==1)?0:(441+16); j<refactred_weight_matrix_mat.cols-(level==1)?16:0; j++){
	// 		refactred_weight_matrix[mm++] = refactred_weight_matrix_mat.at<float>(i,j);
	// 	}
	// }

	double *res;
	// cout << "refactred_weight_matrix mat" << endl;
	// 	for (int i = 0; i <n; i++) 
	// 		cout << refactred_weight_matrix[i] << " | ";
	// 	cout << "flat mat" << endl;
	// 	for (int i = 0; i <genotype_get_size(); i++) 
	// 		cout << flat_matrix[i] << " | ";
	// cout << endl;
	// cout << "matrixz vector" << endl;
	// for (int i = 0; i <matrix.rows * matrix.cols; i++) 
	// 	cout << matrixzvector[i] << " | ";
	// cout << endl;
	// cout << "node types" << endl;
	// for (int i = 0; i <(int)sqrt(genotype_get_size()); i++)
	// 	cout << node_types[i] << " | ";
	// cout << endl;
	
	int asize = genotype_get_size();
	int bsize = matrix.rows * matrix.cols;
	int csize = (int)sqrt(genotype_get_size());
	
	//printf("connections: %d\n", (level_1.cols*level_1.rows)+(level_2.cols*level_2.rows));

	process_network_input(&type, &asize, &bsize, &csize, &(*flat_matrix), &(*matrixzvector), &(*node_types), &res);

	//printf("here now!\n");
	//printf("value: %f\n", *res); //amount of values in the list
	for(int i=1;i<=(int)*res;i++){
		printf("ann output: %f\n", *(res+i));
	}
	
	free(matrixzvector);
	free(node_types);
	free(flat_matrix);
	
	double result;
	if(type == 0){
		result = *(res+((int)*res));  //the last element from recurrent 
	}else{
		result = 1;
		double val = *(res+1);
		for(int i=2;i<=(int)*res;i++){
			if(val < *(res+i)){
				result = i;
				val = *(res+i);
			}
		}
	}
	
	return result;
}

void save_heatmap(Mat mat, char str[80]){
	double min;
	double max;
	cv::minMaxIdx(mat, &min, &max);
	cv::Mat adjMap;
	cv::convertScaleAbs(mat, adjMap, 255 / max);

	imwrite( str, adjMap );
}

int main(int argc, char *argv[])
{
	// int mode = 0;
	// 
	// vector<Graph> string_feature_graph_demo;
	// 
	initFaces();
	// 
	// float diagonal_size = 0.0;
	// 
	// //create string of feature graphs
	// int frames = start_capture(mode, string_feature_graph_demo, 80/*-1*/, diagonal_size, 80);
	// 
	// //make affinity matrix
	// Mat M = match_strings(string_feature_graph_demo, string_feature_graph_demo, diagonal_size);
	// 
	// // char original[80];
	// // snprintf(original, sizeof original, "original.png");
	// // save_heatmap(M, original);
	// 
	// Size size(21,21);//the dst image size,e.g.100x100
	// Mat resized_M;//dst image
	// resize(M,resized_M,size);//resize image
	
	// char reduced[80];
	// snprintf(reduced, sizeof reduced, "reduced.png");
	// save_heatmap(resized_M, reduced);
	
	//cout << resized_M.rows << resized_M.cols << endl;
	
	//initialisation of haskell insterface
	int i;
	    hs_init(&argc, &argv);
	#ifdef __GLASGOW_HASKELL__
	    hs_add_root(__stginit_Safe);
	#endif
	
	int a;
	printf("1 for training detectors, 2 for training nn: ");
	scanf("%d", &a);
	
	if(a == 1){
	//BOF TRAINING
		//bof start hyperneat algorithms
		int generations = 50000;
		int detectors = 10;
		for(int detector_id=1;detector_id<=detectors;detector_id++){
			//bof specify names
			char id[1*sizeof(int)+1];
			sprintf(id, "_%d", detector_id);
			
			char * NEW_GENOTYPE_FILE_NAME = new char[std::strlen(GENOTYPE_FILE_NAME)+std::strlen(id)+1];
		    std::strcpy(NEW_GENOTYPE_FILE_NAME,GENOTYPE_FILE_NAME);
		    std::strcat(NEW_GENOTYPE_FILE_NAME,id);

			char * NEW_GENOTYPE_FITNESS_FILE_NAME = new char[std::strlen(GENOTYPE_FITNESS_FILE_NAME)+std::strlen(id)+1];
		    std::strcpy(NEW_GENOTYPE_FITNESS_FILE_NAME,GENOTYPE_FITNESS_FILE_NAME);
		    std::strcat(NEW_GENOTYPE_FITNESS_FILE_NAME,id);
		
			
			//eof specify names
			
			int parentID = getpid();
	    	char str[1*sizeof(double)];
	    	sprintf(str, "%d", parentID);
	    	char* name_with_extension = (char*)malloc(2+strlen(python_prog)+std::strlen(id)+3*sizeof(char)+1*sizeof(int)+1+sizeof(GENOTYPE_FILE_NAME)+1); //malloc(strlen(python_prog)+strlen(" ")+strlen(" ")+strlen(GENOTYPE_FILE_NAME));
	    	strcpy(name_with_extension, python_prog);
	    	strcat(name_with_extension, id);	
	    	strcat(name_with_extension, ".py");
	    	strcat(name_with_extension, " ");
	    	strcat(name_with_extension, str);
	    	strcat(name_with_extension, " ");
	    	strcat(name_with_extension, GENOTYPE_FILE_NAME);
        	
	    	pid_t pid;
	    	char *argvv[] = {"sh", "-c", name_with_extension, NULL};
	    	int status;
        	
	    	#if (defined _WIN32 || defined __WIN64)
        	
	    	    STARTUPINFO si;
	    	    PROCESS_INFORMATION pi;
        	
	    	    ZeroMemory( &si, sizeof(si) );
	    	    si.cb = sizeof(si);
	    	    ZeroMemory( &pi, sizeof(pi) );
        	
	    	    char str2[strlen(PYTHON_PATH)+strlen(name_with_extension)];
	    	    strcpy(str2, PYTHON_PATH);
	    	    strcat(str2, name_with_extension);
        	
	    	    //0 instead of CREATE_NEW_CONSOLE shows outoput in Webots console
	    	    if (!CreateProcess(NULL, str2, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi))
	    	    {
	    	        printf( "CreateProcess failed (%d).\n", GetLastError() );
	    	    }
        	
	    	    CloseHandle(pi.hThread);
        	
	    	#elif defined __APPLE__
	    	    status = posix_spawn(&pid, "/bin/sh", NULL, NULL, argvv, environ);
	    	#else
        	
	    	#endif
	
			free(name_with_extension);
		}
		//eof start hyperneat algorithms

		//for every generation, use every detector on an a set of images
		for(int j=0;j<generations;j++){			
			printf("generation %d\n", j);
			
			Mat detectors_outputs = Mat(10,4, CV_32F, cvScalar(0.));
			
			for(int detector_id=1;detector_id<=detectors;detector_id++){
				//double detector_output[2] = {0, 0}; //2 detectors

				//bof specify names
				char id[1*sizeof(int)+1];
				sprintf(id, "_%d", detector_id);
				
				char * NEW_GENOTYPE_FILE_NAME = new char[std::strlen(GENOTYPE_FILE_NAME)+std::strlen(id)+1];
			    std::strcpy(NEW_GENOTYPE_FILE_NAME,GENOTYPE_FILE_NAME);
			    std::strcat(NEW_GENOTYPE_FILE_NAME,id);
        	
				char * NEW_GENOTYPE_FITNESS_FILE_NAME = new char[std::strlen(GENOTYPE_FITNESS_FILE_NAME)+std::strlen(id)+1];
			    std::strcpy(NEW_GENOTYPE_FITNESS_FILE_NAME,GENOTYPE_FITNESS_FILE_NAME);
			    std::strcat(NEW_GENOTYPE_FITNESS_FILE_NAME,id);
				//eof specify names
				
				genotype_set_size(442*442);
        		Genotype ann = genotype_create();

////

				//read ANN
				read_ann(ann, NEW_GENOTYPE_FILE_NAME, NEW_GENOTYPE_FITNESS_FILE_NAME, 1, 1);
        		
				for(int sfg=1;sfg<=20;sfg++){
					
					int mode = 0;
					vector<Graph> string_feature_graph_demo;
					float diagonal_size = 0.0;
					//create string of feature graphs
					
					std::stringstream ss;
					ss << sfg;
					std::string full_filename;
					string filename = "saved_sfg_";
					full_filename.append(filename);
					full_filename.append(ss.str());
					full_filename.append(".txt");
					Mat resized_M;
					if(!std::ifstream(full_filename)){
						int frames = start_capture(mode, string_feature_graph_demo, 80/*-1*/, diagonal_size, 80, sfg);
                    	
						//make affinity matrix
						Mat M = match_strings(string_feature_graph_demo, string_feature_graph_demo, diagonal_size);
                    	
						char hm1[80];
						snprintf(hm1, sizeof hm1, "sfg_%d_hm_original.png", sfg);
						save_heatmap(M, hm1);

						Size size(21,21);
						resized_M = Mat(21,21, CV_32F, cvScalar(0.));
						resize(M,resized_M,size);
						
						char hm[80];
						snprintf(hm, sizeof hm, "sfg_%d_hm_reduced.png", sfg);
						save_heatmap(resized_M, hm);
						
						FileStorage fs(full_filename, FileStorage::WRITE);
						fs << "mat" << resized_M;
						fs.release();
					}else{
						FileStorage fs(full_filename, FileStorage::READ);
						fs["mat"] >> resized_M;
						fs.release();
					}
					
					////////
					
					//cout << "resized M: " << resized_M << endl;
					
					//feed affinity matrix into HyperNEAT generated ANN
					int type=0;
					double ann_output = feed(ann, resized_M, type);
				
					//detector_output[floor((detector_id-1)/5)] += (double)std::round(ann_output)/(double)5.0;
					//cout << "setting at: " << (detector_id-1) << " | " << floor((sfg-1)/5) << " value: " << (float)((float)std::round(ann_output)/(float)5.0) << endl;
					if(ann_output > (double)0.5)
						detectors_outputs.at<float>(detector_id-1, floor((sfg-1)/5)) += (float)((float)1.0);
					else
						detectors_outputs.at<float>(detector_id-1, floor((sfg-1)/5)) += (float)0.001;
				}
			}
			
			// if(detectors_outputs.at<float>(0,0) == 0)
			//  	detectors_outputs.at<float>(0,0) = 0.001;
			// if(detectors_outputs.at<float>(0,1) == 0)
			//  	detectors_outputs.at<float>(0,1) = 0.001;
			// if(detectors_outputs.at<float>(1,0) == 0)
			// 	detectors_outputs.at<float>(1,0) = 0.001;
			// if(detectors_outputs.at<float>(1,1) == 0)
			//  	detectors_outputs.at<float>(1,1) = 0.001;
				
			
			for(int detector_id=1;detector_id<=detectors;detector_id++){
				//bof specify names
				char id[1*sizeof(int)+1];
				sprintf(id, "_%d", detector_id);
				
				char * NEW_GENOTYPE_FILE_NAME = new char[std::strlen(GENOTYPE_FILE_NAME)+std::strlen(id)+1];
			    std::strcpy(NEW_GENOTYPE_FILE_NAME,GENOTYPE_FILE_NAME);
			    std::strcat(NEW_GENOTYPE_FILE_NAME,id);
        	
				char * NEW_GENOTYPE_FITNESS_FILE_NAME = new char[std::strlen(GENOTYPE_FITNESS_FILE_NAME)+std::strlen(id)+1];
			    std::strcpy(NEW_GENOTYPE_FITNESS_FILE_NAME,GENOTYPE_FITNESS_FILE_NAME);
			    std::strcat(NEW_GENOTYPE_FITNESS_FILE_NAME,id);
				//eof specify names
				

				
				//get fitness
				//double fitness = 0.5;//measure_fitness(ann_output);
				//cout << "detectors: " << detectors_outputs;
				
				//float* detector1 = detectors_outputs.ptr<float>(0);
				//float* detector2 = detectors_outputs.ptr<float>(1);
				
			    // CvMat* sig1 = cvCreateMat(1, 2, CV_32FC1);
			    // CvMat* sig2 = cvCreateMat(1, 2, CV_32FC1);
			    // 
			    // cvSet2D(sig1, 0, 0, cvScalar(detectors_outputs.at<float>(0,0))); //detector 1 class 1
			    // // cvSet2D(sig1, 0, 1, cvScalar(0));
			    // // cvSet2D(sig1, 0, 2, cvScalar(0));
			    // 			
			    // cvSet2D(sig1, 0, 1, cvScalar(detectors_outputs.at<float>(0,1))); //detector 1 class 2
			    // // cvSet2D(sig1, 1, 1, cvScalar(0));
			    // // cvSet2D(sig1, 1, 2, cvScalar(1));
			    //                 
			    // cvSet2D(sig2, 0, 0, cvScalar(detectors_outputs.at<float>(1,0))); //detector 2 class 1
			    // // cvSet2D(sig2, 0, 1, cvScalar(1));
			    // // cvSet2D(sig2, 0, 2, cvScalar(0));
			    // 
			    // cvSet2D(sig2, 0, 1, cvScalar(detectors_outputs.at<float>(1,1))); //detector 2 class 2
			    // // cvSet2D(sig2, 1, 1, cvScalar(1));
			    // // cvSet2D(sig2, 1, 2, cvScalar(1));
			    // 			
			    // cvSet2D(sig3, 0, 0, cvScalar(detectors_outputs.at<float>(2,0))); //detector 3 class 1
			    // cvSet2D(sig3, 0, 0, cvScalar(detectors_outputs.at<float>(2,1))); //detector 3 class 2
			    // 			
			    // cvSet2D(sig4, 0, 0, cvScalar(detectors_outputs.at<float>(3,0))); //detector 4 class 1
			    // cvSet2D(sig4, 0, 0, cvScalar(detectors_outputs.at<float>(3,1))); //detector 4 class 2
			    // 			
			    // cvSet2D(sig5, 0, 0, cvScalar(detectors_outputs.at<float>(4,0))); //detector 5 class 1
			    // cvSet2D(sig5, 0, 0, cvScalar(detectors_outputs.at<float>(4,1))); //detector 5 class 2
			
			///search...
			
				//cout << "this detector: " << detectors_outputs.at<float>(detector_id-1,0) << ", " << detectors_outputs.at<float>(detector_id-1,1) << ", " << detectors_outputs.at<float>(detector_id-1,2) << endl;

				
				CvMat* pointsForSearch = cvCreateMat(detectors-1, 4, CV_32F); //Insert all 2D points to this vector
				float* pointsForSearch_ = (float *)malloc((sizeof(float)*detectors*4)-(4*sizeof(float)));
				int deviation = 0;
				for(int detector_id_query=1;detector_id_query<=detectors;detector_id_query++){
					if(detector_id_query != detector_id){
						//pointsForSearch.push_back(detectors_outputs.at<float>(detector_id_query-1,0));
						//pointsForSearch.push_back(detectors_outputs.at<float>(detector_id_query-1,1));
						//pointsForSearch.push_back(detectors_outputs.at<float>(detector_id_query-1,2));
						pointsForSearch_[(detector_id_query-1-deviation)*4+0] = detectors_outputs.at<float>(detector_id_query-1,0);
						pointsForSearch_[(detector_id_query-1-deviation)*4+1] = detectors_outputs.at<float>(detector_id_query-1,1);
						pointsForSearch_[(detector_id_query-1-deviation)*4+2] = detectors_outputs.at<float>(detector_id_query-1,2);
						pointsForSearch_[(detector_id_query-1-deviation)*4+3] = detectors_outputs.at<float>(detector_id_query-1,3);
					}else{
						deviation++;
					}
					//
					// pointsForSearch.push_back(Point2f(1, detectors_outputs.at<float>(1,0)));
					// pointsForSearch.push_back(Point2f(1, detectors_outputs.at<float>(1,1)));
					// pointsForSearch.push_back(Point2f(1, detectors_outputs.at<float>(1,2)));
					// //
					// pointsForSearch.push_back(Point2f(2, detectors_outputs.at<float>(2,0)));
					// pointsForSearch.push_back(Point2f(2, detectors_outputs.at<float>(2,1)));
					// pointsForSearch.push_back(Point2f(2, detectors_outputs.at<float>(2,2)));
					// //
					// pointsForSearch.push_back(Point2f(3, detectors_outputs.at<float>(3,0)));
					// pointsForSearch.push_back(Point2f(3, detectors_outputs.at<float>(3,1)));
					// pointsForSearch.push_back(Point2f(3, detectors_outputs.at<float>(3,2)));
					// //
					// pointsForSearch.push_back(Point2f(4, detectors_outputs.at<float>(4,0)));
					// pointsForSearch.push_back(Point2f(4, detectors_outputs.at<float>(4,1)));
					// pointsForSearch.push_back(Point2f(4, detectors_outputs.at<float>(4,2)));
				}
				//for(int q=0;q<(detectors-1)*4;q++)
				//	cout << "points for search: " << pointsForSearch_[q];
				//cout << endl;

				cvSetData(pointsForSearch, pointsForSearch_, pointsForSearch->step); ///detectorN -> col1: behavior1; col2: Behavior2; ...
				
				double total_distance = 0.0;
				for(int detector_id_query2=1;detector_id_query2<=detectors-1;detector_id_query2++){
					CvMat* a_row = cvCreateMat(1, 4, CV_32FC1);
					//pointsForSearch.row(detector_id_query2-1).copyTo(a_row.row(0));
					cvSet2D(a_row, 0, 0, cvGet2D(pointsForSearch, detector_id_query2-1, 0));
					cvSet2D(a_row, 0, 1, cvGet2D(pointsForSearch, detector_id_query2-1, 1));
					cvSet2D(a_row, 0, 2, cvGet2D(pointsForSearch, detector_id_query2-1, 2));
					cvSet2D(a_row, 0, 3, cvGet2D(pointsForSearch, detector_id_query2-1, 3));
					
					CvMat* a_detector = cvCreateMat(1, 4, CV_32FC1); //Insert all 2D points to this vector
					float a_detector_data[4] = {detectors_outputs.at<float>(detector_id-1,0), detectors_outputs.at<float>(detector_id-1,1), detectors_outputs.at<float>(detector_id-1,2), detectors_outputs.at<float>(detector_id-1,3)};
					cvSetData(a_detector, a_detector_data, a_detector->step);
					
					double detectors_manhattan_distance = cvCalcEMD2(a_row, a_detector, CV_DIST_L1, 0, 0, 0, 0, 0) / (float)10.0;
					printf("manhatta distance from this detector to others %f\n", detectors_manhattan_distance);
					
					total_distance += detectors_manhattan_distance;
					
					cvReleaseMat(&a_row);
					cvReleaseMat(&a_detector);
				}
				
					// flann::KDTreeIndexParams indexParams;
					// 				flann::Index kdtree(Mat(pointsForSearch).reshape(1), indexParams);
					// 				
					// 				/////
					// 				
					// 				vector<float> query;
					// 				float average_query = (detectors_outputs.at<float>(detector_id-1, 0) + detectors_outputs.at<float>(detector_id-1, 1) + detectors_outputs.at<float>(detector_id-1, 2)) / (float)3.0;
					// 				query.push_back(average_query);
					// 				//query.push_back(detector_id-1); //Insert the 2D point we need to find neighbours to the query
					// 				//query.push_back(detectors_outputs.at<float>(detector_id-1,1)); //Insert the 2D point we need to find neighbours to the query
					// 				vector<int> indices;
					// 				vector<float> dists;
					// 				kdtree.radiusSearch(query, indices, dists, 100, 15);
					// 				
					// 				float total_distance = 0.0;
					// 				printf("detector: %d\n", detector_id);
					// 				vector<float>::const_iterator it = dists.begin();
					// 				          for( int y = 0; it != dists.end(); ++it, y++ ){
					// 							  printf("distance: %f", *it);
					// 				              total_distance += *it;
					// 						  }
					// 						printf("\n");
			///search
			
				//double detectors_manhattan_distance = cvCalcEMD2(sig1, sig2, CV_DIST_L1, 0, 0, 0, 0, 0) / (float)2.0;
				double fitness = total_distance/(float)10.0; //0.5; //detectors_manhattan_distance;
				
				printf("fitness: %f\n", fitness);
				
				//send fitness
				char output[50];
	    		snprintf(output,50,"%f",fitness);
        		
	    		FILE *file;
	    		file = fopen(NEW_GENOTYPE_FITNESS_FILE_NAME,"w");
	    		fprintf(file, output);
	    		fclose(file);
	
				free(pointsForSearch_);
				cvReleaseMat(&pointsForSearch);
			}
		}
		
	//EOF TRAINING	

	}else if(a == 2){
		
		vector<Genotype> detectors;
		for(int sfg=1;sfg<=20;sfg++){
			vector<double> detector_output_per_video;
			for(int i=1; i<=6; i++){
				
				char id[1*sizeof(int)+1];
				sprintf(id, "_%d", i);

				char * NEW_DETECTOR_FILE_NAME = new char[std::strlen(DETECTOR_FILENAME)+std::strlen(id)+1];
			    std::strcpy(NEW_DETECTOR_FILE_NAME,DETECTOR_FILENAME);
			    std::strcat(NEW_DETECTOR_FILE_NAME,id);

				genotype_set_size(442*442);
				Genotype ann = genotype_create();

				//char *empty_char = new char[1 * sizeof(int)];
				
				char * NEW_GENOTYPE_FITNESS_FILE_NAME = new char[std::strlen(GENOTYPE_FITNESS_FILE_NAME)+std::strlen(id)+1];
			    std::strcpy(NEW_GENOTYPE_FITNESS_FILE_NAME,GENOTYPE_FITNESS_FILE_NAME);
			    std::strcat(NEW_GENOTYPE_FITNESS_FILE_NAME,id);

				//for every detector,
				read_ann(ann, NEW_DETECTOR_FILE_NAME, NEW_GENOTYPE_FITNESS_FILE_NAME, 0, 1);

				//detectors.push_back(ann);
				
				int mode = 0;
				vector<Graph> string_feature_graph_demo;
				float diagonal_size = 0.0;
				//create string of feature graphs
				
				std::stringstream ss;
				ss << sfg;
				std::string full_filename;
				string filename = "test_data_saved_sfg_";
				full_filename.append(filename);
				full_filename.append(ss.str());
				full_filename.append(".txt");
				Mat resized_M;
				if(!std::ifstream(full_filename)){
					int frames = start_capture(mode, string_feature_graph_demo, 80/*-1*/, diagonal_size, 80, sfg);
                	
					//make affinity matrix
					Mat M = match_strings(string_feature_graph_demo, string_feature_graph_demo, diagonal_size);
                	
					char hm1[80];
					snprintf(hm1, sizeof hm1, "test_data_sfg_%d_hm_original.png", sfg);
					save_heatmap(M, hm1);
            
					Size size(21,21);
					resized_M = Mat(21,21, CV_32F, cvScalar(0.));
					resize(M,resized_M,size);
					
					char hm[80];
					snprintf(hm, sizeof hm, "test_data_sfg_%d_hm_reduced.png", sfg);
					save_heatmap(resized_M, hm);
					
					FileStorage fs(full_filename, FileStorage::WRITE);
					fs << "mat" << resized_M;
					fs.release();
				}else{
					FileStorage fs(full_filename, FileStorage::READ);
					fs["mat"] >> resized_M;
					fs.release();
				}
				
				//print_genotype(ann);
				
				//for every detector, 
				int type=0;
				double ann_output = feed(ann, resized_M, type);
				
				detector_output_per_video.push_back(ann_output);
			}
			
			//feed outputs to simple nn
			printf("video %d : ", sfg);
			for (auto vec : detector_output_per_video)
				std::cout << vec << " | ";
			printf("\n");
		}
	}else if(a == 3){
		int dummy=0;
		train(&dummy);
	}else if(a == 4){
	
		//use both detector networks and nn network
		
		//get detectors
		vector<Genotype> detectors;
		for(int i=1; i<=6; i++){
			
			char id[1*sizeof(int)+1];
			sprintf(id, "_%d", i);

			char * NEW_DETECTOR_FILE_NAME = new char[std::strlen(DETECTOR_FILENAME)+std::strlen(id)+1];
		    std::strcpy(NEW_DETECTOR_FILE_NAME,DETECTOR_FILENAME);
		    std::strcat(NEW_DETECTOR_FILE_NAME,id);

			genotype_set_size(442*442);
			Genotype ann = genotype_create();
			
			char * NEW_GENOTYPE_FITNESS_FILE_NAME = new char[std::strlen(GENOTYPE_FITNESS_FILE_NAME)+std::strlen(id)+1];
		    std::strcpy(NEW_GENOTYPE_FITNESS_FILE_NAME,GENOTYPE_FITNESS_FILE_NAME);
		    std::strcat(NEW_GENOTYPE_FITNESS_FILE_NAME,id);

			//for every detector,
			read_ann(ann, NEW_DETECTOR_FILE_NAME, NEW_GENOTYPE_FITNESS_FILE_NAME, 0, 1);
			
			detectors.push_back(ann);
		}
		/////////////////////////////////////////
		// 
		//get ann
		// char id[1*sizeof(int)+1];
		// sprintf(id, "_%d", i);
		// 
		// genotype_set_size(121);
		// Genotype ann = genotype_create();
		// 
		// char * NEW_GENOTYPE_FITNESS_FILE_NAME = new char[std::strlen(GENOTYPE_FITNESS_FILE_NAME)+std::strlen(id)+1];
		// 	    std::strcpy(NEW_GENOTYPE_FITNESS_FILE_NAME,GENOTYPE_FITNESS_FILE_NAME);
		// 	    std::strcat(NEW_GENOTYPE_FITNESS_FILE_NAME,id);
		// 
		// //for every detector,
		// read_ann(ann, NN_FILENAME, NEW_GENOTYPE_FITNESS_FILE_NAME, 0, 1);
		cout << "1"<< endl;
		int type=0;
		while(true){
			int mode = 1;
			vector<Graph> string_feature_graph_demo;
			float diagonal_size = 0.0;
			Mat resized_M;

			int frames = start_capture(mode, string_feature_graph_demo, 16/*-1*/, diagonal_size, 16, -1);

			//make affinity matrix
			Mat M = match_strings(string_feature_graph_demo, string_feature_graph_demo, diagonal_size);

					// char hm1[80];
					// snprintf(hm1, sizeof hm1, "temp.png");
					// save_heatmap(M, hm1);

			Size size(21,21);
			resized_M = Mat(21,21, CV_32F, cvScalar(0.));
			resize(M,resized_M,size);
			
			vector<double> detector_outputs;
			
			genotype_set_size(442*442);
			
			type=0;
			for(int k=0;k<detectors.size();k++){
				double ann_output = feed(detectors[k], resized_M, type);
				//cout << "out : " << ann_output << endl;
				detector_outputs.push_back(ann_output);
			}			
			//print_genotype(ann);
			
			genotype_set_size(121);
			
			cout << "--" << endl;
			
			type=1;
			cv::Mat inputs(detector_outputs, true);
			double ann_output = feed(detectors[0], inputs, type);
			
			cout << "class is: " << ann_output << endl;
		}
	}
	
	return 0;
}
